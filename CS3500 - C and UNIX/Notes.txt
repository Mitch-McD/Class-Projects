cmdDownloaded PuTTY

Access UNIX server:
Open CMD, "putty"
connect to cs.ucmo.edu in popup, leave settings as default
login with mlm13510
password is UCM password

i = insert
: = ?
w = write (save)
q = quit
x = delete highlighted character
dd = delete entire line
u = undo 
/<string> = search for string in file
:3 = go to line number three

Exit with saving: escape, then :wq
Exit without saving: escape, then :q!

8/18
ls = list files
top = list ? 
q = quit top
mkdir <name> = make directory
mv <file> <destination> = move file
^ can also be used to rename files, move file to file
cd = change directory, just like cmd prompt
cp <source> <dest> = copy file, if dest does not exist it will be created, if it does it will be overridden
rm <file> = remove/delete file
grep "string" = search, use * after to search all files (not subdir) in the current directory
^ add -r to search all files
zip <zip file name> <folder to zip> = zips folder or file into a zip file
unzip <zip file name> 
man <command> = command search, shows all possible flags for the command, up and down arrows to scroll, q to quit
pwd = shows full current directory on the server starting from the home directory

#include <file> (or "file") = include library to use in the C program - stdio.h is for standard input/output
<> means system file (from system directory?), "" means local file (starting point is the directory the file editing is in)
printf is included in stdio.h, same as System.out.printf in Java
no classes in C, just return type and function name, and parameters
main is starting point for program just like Java
two forms for main: 
main() - no args
main(2 args) - ???
compile file:
gcc <file name> = compile file, can rename file using -o <name> 
./<executable name> = run file, executable name is generated by the gcc or configured

8/20
struct - similar to Java Class? 
C does not have strings, character arrays must be made instead (char name[x];)
unsigned int - no negative or positive symbol attached, always positive (absolute value)
strcpy = Turning a string into a char array, need to include <string.h>
^ strcpy(<char array>, "string");

8/23
typedef = define data type, used to create datatype aliases - unsigned int to UINT
const char *monthName[] - Two dimensional array? Star means variable length???
enum = list of integers, use as constants that will not change, can be started at any number?
union = similar to struct? 

8/25
union variable allows for a variable to hold multiple data types, but one at a time
union {
int integer;
char string[N];
float real;
} val;
assign stuff:
data[0].val.integer = 3;
data[1].val.real = 2.0;
strcpy(data[2].val.string, "yeet");
Homework Assignment: 

Implement Print Matrix
	PrintMatrix(M);
Calc average of the matrix, should be 148? 
	float ave = ComputeAverage(M);
	int dc = round(ave); // round the average
Subtract value: 
	Subtract average from each member of the matrix and then display
	Matrix M2 = Add(m, -dc);
	PrintMatrix(M2);
Transpose matrix: 
	Flip i and j indexes, 0/0 stays 0/0, 0/1 becomse 1/0, 0/2 becomes 	2/0, etc:
	Matrix T2 = MatrixTranspose(M);
	PrintMatrix(T2);
Multiplication (Matrix x Matrix):
	Matrix R = MatrixElementMult(Q50, M);
	PrintMatrix(R);
Division (Matrix / Matrix);
	Matrix C = MatrixElementDiv(R, Q50);
	PrintMatrix(C);
Read ch 10 for last week and ch 9 for stdio?
int main(int argc, char **argv) 
argc = amount of arguments given when called at the command line: 
./program = 1
./program yeet mcskeet = 3

9/1
Matrix Multiplication
(2x3)(3x2) 
the position that the three holds has to be the same
(mxp)(pxn) = (mxn)
Multiplication works as: 
1, 2, 3
4, 5, 6
X
7, 8
9, 10
11, 12
1x7 + 2x9 + 3x11 = 58, first element in answer matrix
1x8 + 2x10 + 3x12 = 64

4x7 + 5x9 + 6x11 = 139
4x8 + 4x10 + 4x12 = 154
AB != BA when matrix multiplication
fgets(buf2, 80, stdin); - can be used for files as well, replace stdin with file name - "read one line", up to 80 characters or return? 

Function pointers: 

void foo(x) {x=0;}
...
foo(x);
^ will NOT change x

void foo(*x) {*x=0;}
...
foo(&x);
^ will change x to 0

9/13
extren - init a variable or function that is defined in another file i.e.
file 1: 
extern int yeet
extern int foo(int x)

main
foo(10)

file 2: 
int var = 0;
foo(int x)
    x++;

- h files
#ifndef _TEST4_H
#define _TEST4_H
#endif
Defines the file once and only once, if not defined define, otherwise do nothing
- Never include a .c file, only .h
makefile:

make -f othermakefile

9/15
CC = compiler
DEPS = dependents?
variable definitions ^

$(CC) - reference variable

smallest unit that can be saved on a disk is a BYTE (8 bits)
negative numbers in binary: 
8th 0 = negative or positve sign, 7 other 0s range from 127 to -127 (still 255)

9/27
File - a collection of bytes stored in secondary storage devices
operating with files allows for more complex tasks
types of Files - ASCII, or Binary files with different encoding schemata
Basic file operations:
open
create
close
read
write
Data type: FILE
File pointer needed, asterisk indicates pointer: 
FILE  *fp;
FILE *fp = fopen(filename, mode);
-r - opens in read
-w - opens in write
-a - opens in append
- r+ - opens file for r&w mode and sets pointer to first character in the file
- w+ - opens file for r&w? mode and sets pointer to first character in the file
- a+ -? 
rb - read binary
wb - write binary
rt, r - read text file
wt, w - write text file
Filename - char*
Mode - char*

fopen - creates new file or opens existing file
fclose closes an opened file
getw reads an int from file
putw writes an int to file
fgetc reads character from file
fputc writes character to file
? 
fputs writes string to file
feof finds end of file
fgetchar reads character from keyboard
fprintf writes formatted data to a file
fscanf read sformatted data from file
fputchar writes character onto the output screen from keyboard
fseek moves file pointer position to given location

SEEK_SET - parameter, moves file pointer position to beginning of file
SEEK_CUR - moves filer pointer to location
SEEK_END - moves file pointer to end of file
ftell - gives current position of pointer
rewind - moves file pointer back to beginning
fflush - flushes a file
remove deletes a file
sscanf reads formatted input from a string
scanf reads formatted data from the keyboard
sprinf writes formatted output to a string

first thing to do is to check if *fp is valid (not null) 

9/29
when file open, you can specify that file is binary? 
binary data file - stream of characters, character = one byte
fread(void *ptr, size_t size, size_t, nmemb, FILE *stream)
ptr = file pointer
size_t:
	size: size in bytes of each element to be read
	nmemb: number of elements
multiply size by nmemb to determine how many bytes to be read total

fwrite(const void *data, size_t size, size_t nmemb, FILE *stream
fread but you write instead of read? 
data[N] = {1,2,3,4,5}
FILE *fp = fopen(filename, "wb")
fwrite(data, sizeof(unsigned char), length, fp)

//fwrite only way to write binary data to a file

fclose(fp)

! -- See slides for code examples

to find file size in bytes/characters:
	fseek(fp, 0, SEEK_END); // seeks the very end
	int fileSize = ftell(fp); // gets the position of the pointer
	rewind(fp); // resets the pointer position
10/6
GDB - ???
code debugger? 
call variables
next - go to next breakpoint or line?
clear - clear current breakpoint
continue - continue program? 
display <value> - displays variable
quit - quit out of gdb
break <line number> - create breakpoint @ line 
set <variable> <value> - sets a variable to a value
list - shows code from current pos? 

Difference between Java and C: Java handles garbage collection/memory leaks automatically, but you don't know when
C: Developer (or User?) handles garbage collection/memory and can control when it happens

if array size or variable size is too big, segmentation fault
how to acquire mem: 

int *data = (int *) malloc(100000000 * sizeof(int)); - 100000000 int-sized array elements

free(data); - releases the data - MUST do this!

malloc = memory allocation

calloc = memory allocation, but two parameters instead (and initializes every array element to 0?) and takes longer: 
calloc(100000000, sizeof(int));

realloc = re-allocate, allocates more mem from variable given and more: 
int *data = (int *) malloc(5 * sizeof(int)); - data has 5
int *data1 = (int *) realloc(data, 10 * sizeof(int)); data1 has 10, first 5 are data
free(data2); - releases both data and data1

10/11
memset(data, 'A', 10*sizeof(BYTE)); - System command, sets all of data (1d array) to 'A', much faster than for looping through the array and manually setting each value
memset(buf+7, '.', 4*sizeof(char)); - starts on the 7th character in buf and replaces it and three more characters (for a total of 4) to '.'
"I love Java and C" -> "I love .... and C" 
memcpy(data, buf, N*sizeof(char)); - copies from buf to data each value? 
memmove(buf+16, p, sizeof(p)); - appends p (array) to buf at position 16
I love java and c -> I love java and c++ and python

10/13
& = unary operator, produces an address
* = unary operator, deference a pointer

int** Allocate2DMem(int m, int n)
int** data = (int**) malloc(m * sizeof(int*)); // assign a one dimension array full of int* (int array length) mem allocation
int i;
for (i) 
	data[i] = (int*) malloc(n*sizeof(int));

return data;

void Free2DMem(int** data, int m, int n)
int i
for (i)
	free(data[i])
free(data)

time ./programname - get time benchmark of program runtime

valgrind ./programname - memory error detector

10/18/21
value checker for assignment 4 {
if (buf[i] == result[i])
x = 0;
else 
x = 1;
break;

if x == 1
printf("something's off")
}

int *countPtr, count; 
char *dataPtr, ch; 

Pointer - Points to value. Definitions: int *countPtr, count; countPtr points to count

10/20
int *ptr = NULL; // always assign pointers to NULL initially
&*ptr = *&ptr = ptr
&* together cancel eachother out
Pointer data type must match value pointing to because pointer increment increments the memory location by the amount of bytes it takes to store the value
int *ptr = data array
ptr++ = 3000 -> 3004
ptr + 2 = 3000 - > 3008
because int size is 4 bytes

10/27
Difference between pointer and array: 
Array size can vary based on data type
Pointer size is always constant, because it contains a single mem address pointing to something
function pointers: 
<function return type>(*<pointer name>)(<parameter types>) 
int sum(int a, int b) {return a + b}

int (*f2p)(int, int);
f2p = &sum;

void (*f)();
f = &otherFunction();

int (*cmp)(const void*, const void*);
int data[] = {1,2,3,4,5,6,7,8,9,10};
cmp = &compare1;
qsort(data, sizeof(data)/sizeof(int), sizeof(int), cmp) - quick sort

data = data to sort, sizeof(data)/sizeof(int) = amount of elements, sizeof(int) = size of each element, cmp = compare function


